// serve-gym-hybrid-final.js - Servidor GYM P2 H√≠brido Completo
const express = require("express");
const cors = require("cors");
const http = require("http");
const socketIo = require("socket.io");
const fs = require("fs").promises;
const path = require("path");
const crypto = require("crypto");
const mysql = require("mysql2/promise");

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: { origin: "*", methods: ["GET", "POST", "PUT", "DELETE"] }
});

// ========== CONFIGURA√á√ïES ==========
const PORT = 3000;
const DATA_DIR = path.join(__dirname, 'data');

// Configura√ß√£o MySQL
const dbConfig = {
    host: 'localhost',
    user: 'root',
    password: 'Juan2800JG11',
    database: 'gym_p2',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    connectTimeout: 10000
};

// Pool de conex√µes MySQL
let pool;

// Arquivos de dados JSON (backup/local)
const FILES = {
    academias: path.join(DATA_DIR, 'academias.json'),
    proprietarios: path.join(DATA_DIR, 'proprietarios.json'),
    personais: path.join(DATA_DIR, 'personais.json'),
    admins: path.join(DATA_DIR, 'admins.json'),
    usuarios: path.join(DATA_DIR, 'usuarios.json'),
    sessoes: path.join(DATA_DIR, 'sessoes.json')
};

// ========== MIDDLEWARE ==========
app.use(cors({
    origin: '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.static('public'));

// Middleware de logging
app.use((req, res, next) => {
    console.log(`üì• ${req.method} ${req.url} - IP: ${req.ip || req.connection.remoteAddress}`);
    next();
});

// Middleware de autentica√ß√£o
const authMiddleware = async (req, res, next) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token && req.path.startsWith('/api/protegido')) {
        return res.status(401).json({ error: 'Token n√£o fornecido' });
    }
    
    if (token) {
        try {
            const usuario = await verificarSessao(token);
            if (usuario) {
                req.user = usuario;
            }
        } catch (error) {
            console.log('Token inv√°lido:', error.message);
        }
    }
    
    next();
};

app.use(authMiddleware);

// Middleware de conex√£o MySQL
app.use((req, res, next) => {
    req.db = pool;
    next();
});

// ========== FUN√á√ïES UTILIT√ÅRIAS ==========

// Hash de senhas
function hashPassword(password, salt = null) {
    if (!salt) {
        salt = crypto.randomBytes(16).toString('hex');
    }
    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
    return { hash, salt };
}

function verifyPassword(password, hash, salt) {
    const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
    return hash === verifyHash;
}

// Gera token de sess√£o
function gerarToken() {
    return crypto.randomBytes(32).toString('hex');
}

// ========== FUN√á√ïES DO BANCO DE DADOS ==========

// Inicializar MySQL ou JSON
async function initDatabase() {
    try {
        pool = mysql.createPool(dbConfig);
        
        // Testar conex√£o
        const connection = await pool.getConnection();
        console.log('‚úÖ Conectado ao MySQL com sucesso!');
        connection.release();
        
        // Criar banco de dados se n√£o existir
        await createDatabase();
        
        // Criar tabelas
        await createTables();
        
        console.log('‚úÖ Banco de dados MySQL inicializado!');
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao conectar ao MySQL:', error.message);
        console.log('‚ö†Ô∏è  Usando armazenamento local (JSON)');
        pool = null;
        return false;
    }
}

async function createDatabase() {
    try {
        const connection = await mysql.createConnection({
            host: dbConfig.host,
            user: dbConfig.user,
            password: dbConfig.password
        });
        
        await connection.query(`CREATE DATABASE IF NOT EXISTS ${dbConfig.database}`);
        await connection.query(`USE ${dbConfig.database}`);
        await connection.end();
    } catch (error) {
        console.error('Erro ao criar banco:', error.message);
    }
}

async function createTables() {
    if (!pool) return;

    const queries = [
        // Tabela de usu√°rios
        `CREATE TABLE IF NOT EXISTS usuarios (
            id INT AUTO_INCREMENT PRIMARY KEY,
            nome VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            password_hash VARCHAR(255) NOT NULL,
            password_salt VARCHAR(255) NOT NULL,
            role VARCHAR(20) DEFAULT 'user',
            status VARCHAR(20) DEFAULT 'ativo',
            criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            ultimo_login TIMESTAMP NULL,
            telefone VARCHAR(20),
            endereco TEXT,
            avatar_url VARCHAR(500),
            INDEX idx_email (email)
        )`,

        // Tabela de administradores
        `CREATE TABLE IF NOT EXISTS administradores (
            id INT AUTO_INCREMENT PRIMARY KEY,
            nome VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            password_hash VARCHAR(255) NOT NULL,
            password_salt VARCHAR(255) NOT NULL,
            nivel VARCHAR(20) DEFAULT 'admin',
            status VARCHAR(20) DEFAULT 'ativo',
            telefone VARCHAR(20),
            observacoes TEXT,
            criado_por VARCHAR(100),
            data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            ultimo_acesso TIMESTAMP NULL,
            data_atualizacao TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,
            INDEX idx_email (email)
        )`,

        // Tabela de academias
        `CREATE TABLE IF NOT EXISTS academias (
            id INT AUTO_INCREMENT PRIMARY KEY,
            nome VARCHAR(100) NOT NULL,
            tipo VARCHAR(50) DEFAULT 'musculacao',
            descricao TEXT,
            cnpj VARCHAR(20),
            email VARCHAR(100),
            telefone VARCHAR(20),
            endereco VARCHAR(200),
            cidade VARCHAR(100),
            estado CHAR(2),
            cep VARCHAR(10),
            bairro VARCHAR(100),
            numero VARCHAR(10),
            complemento VARCHAR(100),
            proprietario_id INT,
            status VARCHAR(20) DEFAULT 'ativo',
            foto_url VARCHAR(500),
            preco_mensal DECIMAL(10,2),
            horario_abertura TIME,
            horario_fechamento TIME,
            facilidades TEXT,
            data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            data_atualizacao TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,
            latitude DECIMAL(10,8),
            longitude DECIMAL(11,8),
            INDEX idx_status (status)
        )`,

        // Tabela de propriet√°rios
        `CREATE TABLE IF NOT EXISTS proprietarios (
            id INT AUTO_INCREMENT PRIMARY KEY,
            nome VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE,
            cpf VARCHAR(14),
            telefone VARCHAR(20),
            endereco VARCHAR(200),
            data_nascimento DATE,
            status VARCHAR(20) DEFAULT 'ativo',
            data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            data_atualizacao TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,
            INDEX idx_email (email)
        )`,

        // Tabela de personais
        `CREATE TABLE IF NOT EXISTS personais (
            id INT AUTO_INCREMENT PRIMARY KEY,
            nome VARCHAR(100) NOT NULL,
            email VARCHAR(100),
            telefone VARCHAR(20),
            cref VARCHAR(20),
            especialidade VARCHAR(100),
            anos_experiencia INT,
            academia_id INT,
            cidade VARCHAR(100),
            bairros TEXT,
            sobre TEXT,
            expectativas TEXT,
            status VARCHAR(20) DEFAULT 'pendente',
            avaliacao DECIMAL(3,2) DEFAULT 0,
            foto_url VARCHAR(500),
            data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            data_atualizacao TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,
            INDEX idx_status (status)
        )`,

        // Tabela de sess√µes
        `CREATE TABLE IF NOT EXISTS sessoes (
            id INT AUTO_INCREMENT PRIMARY KEY,
            token VARCHAR(255) UNIQUE NOT NULL,
            usuario_id INT,
            usuario_email VARCHAR(100),
            ip_address VARCHAR(45),
            user_agent TEXT,
            criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            expira_em TIMESTAMP NULL,
            INDEX idx_token (token),
            INDEX idx_expira (expira_em)
        )`,

        // Tabela de logs
        `CREATE TABLE IF NOT EXISTS logs (
            id INT AUTO_INCREMENT PRIMARY KEY,
            tipo VARCHAR(50) NOT NULL,
            usuario_id INT,
            usuario_email VARCHAR(100),
            acao VARCHAR(100),
            dados TEXT,
            ip_address VARCHAR(45),
            user_agent TEXT,
            criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            INDEX idx_tipo (tipo)
        )`
    ];

    for (const query of queries) {
        try {
            await pool.query(query);
        } catch (error) {
            console.error('Erro ao criar tabela:', error.message);
        }
    }
}

// Inicializa√ß√£o dos arquivos de dados JSON (fallback)
async function initDataDir() {
    try {
        await fs.mkdir(DATA_DIR, { recursive: true });
        console.log('‚úÖ Diret√≥rio de dados verificado');
        
        for (const [key, filepath] of Object.entries(FILES)) {
            try {
                await fs.access(filepath);
                console.log(`üìÑ ${key}.json j√° existe`);
            } catch {
                let initialData;
                
                switch(key) {
                    case 'admins':
                        initialData = [{
                            id: 1,
                            nome: "Admin Master",
                            email: "admin@gym.com",
                            nivel: "super_admin",
                            status: "ativo"
                        }];
                        break;
                        
                    case 'usuarios':
                        initialData = {
                            sistema: "Gymp2 - Sistema Seguro",
                            versao: "2.0",
                            criado_em: new Date().toISOString(),
                            total_usuarios: 0,
                            usuarios: {},
                            logs: []
                        };
                        break;
                        
                    case 'sessoes':
                        initialData = { sessoes: {} };
                        break;
                        
                    default:
                        initialData = [];
                }
                
                await fs.writeFile(filepath, JSON.stringify(initialData, null, 2));
                console.log(`üìÑ ${key}.json criado`);
            }
        }
    } catch (error) {
        console.error('‚ùå Erro ao inicializar dados:', error);
    }
}

// Fun√ß√µes de leitura/escrita JSON (fallback)
async function readData(type) {
    try {
        const data = await fs.readFile(FILES[type], 'utf8');
        return JSON.parse(data);
    } catch (error) {
        console.error(`Erro ao ler ${type}:`, error.message);
        return type === 'usuarios' || type === 'sessoes' ? {} : [];
    }
}

async function writeData(type, data) {
    try {
        await fs.writeFile(FILES[type], JSON.stringify(data, null, 2));
        console.log(`üíæ ${type} salvo com sucesso!`);
        return true;
    } catch (error) {
        console.error(`‚ùå Erro ao salvar ${type}:`, error);
        return false;
    }
}

// Gerenciamento de sess√µes (H√≠brido)
async function limparSessoesExpiradas() {
    if (pool) {
        await pool.query('DELETE FROM sessoes WHERE expira_em < NOW()');
    } else {
        const sessoes = await readData('sessoes');
        const agora = Date.now();
        const EXPIRACAO = 24 * 60 * 60 * 1000;

        Object.keys(sessoes.sessoes).forEach(token => {
            const sessao = sessoes.sessoes[token];
            if (agora - sessao.criado_em > EXPIRACAO) {
                delete sessoes.sessoes[token];
            }
        });

        await writeData('sessoes', sessoes);
    }
}

async function verificarSessao(token) {
    await limparSessoesExpiradas();
    
    if (pool) {
        const [rows] = await pool.query(
            'SELECT s.*, u.nome, u.email, u.role FROM sessoes s JOIN usuarios u ON s.usuario_id = u.id WHERE s.token = ? AND s.expira_em > NOW()',
            [token]
        );
        
        if (rows.length === 0) return null;
        
        return {
            name: rows[0].nome,
            email: rows[0].email,
            role: rows[0].role
        };
    } else {
        const sessoes = await readData('sessoes');
        const sessao = sessoes.sessoes[token];

        if (!sessao) return null;

        const db = await readData('usuarios');
        const usuario = db.usuarios[sessao.email];

        if (!usuario) return null;

        return {
            name: usuario.name,
            email: usuario.email,
            role: usuario.role
        };
    }
}

// Logs de atividade (H√≠brido)
async function registrarLog(tipo, dados) {
    if (pool) {
        await pool.query(
            'INSERT INTO logs (tipo, usuario_email, acao, dados, ip_address) VALUES (?, ?, ?, ?, ?)',
            [tipo, dados.email || 'sistema', dados.acao || tipo, JSON.stringify(dados), dados.ip || 'localhost']
        );
    } else {
        const db = await readData('usuarios');
        
        const log = {
            id: Date.now(),
            timestamp: new Date().toISOString(),
            tipo: tipo,
            dados: dados,
            ip: dados.ip || 'localhost'
        };

        db.logs.push(log);
        
        if (db.logs.length > 1000) {
            db.logs = db.logs.slice(-1000);
        }

        await writeData('usuarios', db);
    }
}

// Fun√ß√£o para obter estat√≠sticas do dashboard
async function getDashboardStats() {
    if (pool) {
        const [academias] = await pool.query('SELECT COUNT(*) as total, SUM(CASE WHEN status = "ativo" THEN 1 ELSE 0 END) as ativas FROM academias');
        const [proprietarios] = await pool.query('SELECT COUNT(*) as total FROM proprietarios');
        const [personais] = await pool.query('SELECT COUNT(*) as total FROM personais');
        const [usuarios] = await pool.query('SELECT COUNT(*) as total FROM usuarios');
        const [sessoes] = await pool.query('SELECT COUNT(*) as total FROM sessoes WHERE expira_em > NOW()');
        
        return {
            total_academias: academias[0].total,
            academias_ativas: academias[0].ativas,
            total_proprietarios: proprietarios[0].total,
            total_personais: personais[0].total,
            total_usuarios: usuarios[0].total,
            sessoes_ativas: sessoes[0].total
        };
    } else {
        const academias = await readData('academias');
        const proprietarios = await readData('proprietarios');
        const personais = await readData('personais');
        const dbUsuarios = await readData('usuarios');
        const sessoes = await readData('sessoes');
        
        return {
            total_academias: academias.length,
            academias_ativas: academias.filter(a => a.status === 'ativo').length,
            total_proprietarios: proprietarios.length,
            total_personais: personais.length,
            total_usuarios: dbUsuarios.total_usuarios || 0,
            sessoes_ativas: Object.keys(sessoes.sessoes || {}).length
        };
    }
}

// Fun√ß√£o para notificar atualiza√ß√µes p√∫blicas
async function notifyPublicUpdate(type, data) {
    io.to('public-updates').emit('public-update', {
        type: type,
        data: data,
        timestamp: new Date().toISOString()
    });
    console.log(`üì¢ Notifica√ß√£o p√∫blica enviada: ${type}`);
}

// ========== ROTAS DE AUTENTICA√á√ÉO ==========

app.post("/cadastro", async (req, res) => {
    try {
        const { name, email, password } = req.body;

        if (!name || !email || !password) {
            return res.status(400).json({ 
                success: false, 
                message: 'Todos os campos s√£o obrigat√≥rios' 
            });
        }

        if (password.length < 6) {
            return res.status(400).json({ 
                success: false, 
                message: 'Senha deve ter no m√≠nimo 6 caracteres' 
            });
        }

        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({ 
                success: false, 
                message: 'Email inv√°lido' 
            });
        }

        if (pool) {
            const [rows] = await pool.query(
                'SELECT id FROM usuarios WHERE email = ?', 
                [email]
            );
            
            if (rows.length > 0) {
                return res.status(400).json({ 
                    success: false, 
                    message: 'Email j√° cadastrado' 
                });
            }

            const { hash, salt } = hashPassword(password);

            const [result] = await pool.query(
                `INSERT INTO usuarios (nome, email, password_hash, password_salt, role) 
                 VALUES (?, ?, ?, ?, 'user')`,
                [name, email, hash, salt]
            );

            await registrarLog('cadastro_sucesso', { 
                email, 
                name,
                acao: 'novo_usuario'
            });

            res.json({ 
                success: true, 
                message: 'Conta criada com sucesso!',
                user: { name, email, role: 'user' }
            });
        } else {
            const db = await readData('usuarios');

            if (db.usuarios[email]) {
                await registrarLog('cadastro_falha', { 
                    email, 
                    motivo: 'email_existente' 
                });
                return res.status(400).json({ 
                    success: false, 
                    message: 'Email j√° cadastrado' 
                });
            }

            const { hash, salt } = hashPassword(password);

            db.usuarios[email] = {
                name,
                email,
                passwordHash: hash,
                passwordSalt: salt,
                role: 'user',
                criado_em: new Date().toISOString(),
                ultimo_login: null
            };

            db.total_usuarios = Object.keys(db.usuarios).length;
            await writeData('usuarios', db);

            await registrarLog('cadastro_sucesso', { email, name });

            res.json({ 
                success: true, 
                message: 'Conta criada com sucesso!',
                user: { name, email, role: 'user' }
            });
        }
    } catch (error) {
        console.error('Erro no cadastro:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erro interno no servidor' 
        });
    }
});

app.post("/login", async (req, res) => {
    try {
        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({ 
                success: false, 
                message: 'Email e senha s√£o obrigat√≥rios' 
            });
        }

        if (pool) {
            const [rows] = await pool.query(
                'SELECT * FROM usuarios WHERE email = ? AND status = "ativo"',
                [email]
            );

            if (rows.length === 0) {
                await registrarLog('login_falha', { 
                    email, 
                    motivo: 'email_nao_encontrado' 
                });
                return res.status(401).json({ 
                    success: false, 
                    message: 'Email n√£o encontrado' 
                });
            }

            const usuario = rows[0];
            
            const senhaCorreta = verifyPassword(password, usuario.password_hash, usuario.password_salt);
            
            if (!senhaCorreta) {
                await registrarLog('login_falha', { 
                    email, 
                    motivo: 'senha_incorreta' 
                });
                return res.status(401).json({ 
                    success: false, 
                    message: 'Senha incorreta' 
                });
            }

            await pool.query(
                'UPDATE usuarios SET ultimo_login = NOW() WHERE id = ?',
                [usuario.id]
            );

            const token = gerarToken();
            const expiraEm = new Date(Date.now() + 24 * 60 * 60 * 1000);

            await pool.query(
                `INSERT INTO sessoes (token, usuario_id, usuario_email, ip_address, expira_em) 
                 VALUES (?, ?, ?, ?, ?)`,
                [token, usuario.id, email, req.ip, expiraEm]
            );

            await registrarLog('login_sucesso', { 
                email, 
                name: usuario.nome,
                acao: 'login' 
            });

            res.json({
                success: true,
                message: 'Login realizado com sucesso!',
                token,
                user: {
                    id: usuario.id,
                    name: usuario.nome,
                    email: usuario.email,
                    role: usuario.role
                }
            });
        } else {
            const db = await readData('usuarios');
            const usuario = db.usuarios[email];

            if (!usuario) {
                await registrarLog('login_falha', { 
                    email, 
                    motivo: 'email_nao_encontrado' 
                });
                return res.status(401).json({ 
                    success: false, 
                    message: 'Email n√£o encontrado' 
                });
            }

            const senhaCorreta = verifyPassword(password, usuario.passwordHash, usuario.passwordSalt);

            if (!senhaCorreta) {
                await registrarLog('login_falha', { 
                    email, 
                    motivo: 'senha_incorreta' 
                });
                return res.status(401).json({ 
                    success: false, 
                    message: 'Senha incorreta' 
                });
            }

            usuario.ultimo_login = new Date().toISOString();
            await writeData('usuarios', db);

            const token = gerarToken();
            const sessoes = await readData('sessoes');
            
            sessoes.sessoes[token] = {
                email,
                criado_em: Date.now(),
                ip: req.ip || req.connection.remoteAddress
            };

            await writeData('sessoes', sessoes);
            await registrarLog('login_sucesso', { 
                email, 
                name: usuario.name 
            });

            res.json({
                success: true,
                message: 'Login realizado com sucesso!',
                token,
                user: {
                    name: usuario.name,
                    email: usuario.email,
                    role: usuario.role
                }
            });
        }
    } catch (error) {
        console.error('Erro no login:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erro interno no servidor' 
        });
    }
});

app.post("/verificar-sessao", async (req, res) => {
    try {
        const { token } = req.body;
        
        if (!token) {
            return res.status(400).json({ 
                success: false, 
                message: 'Token n√£o fornecido' 
            });
        }

        const usuario = await verificarSessao(token);

        if (!usuario) {
            return res.status(401).json({ 
                success: false, 
                message: 'Sess√£o inv√°lida ou expirada' 
            });
        }

        res.json({
            success: true,
            user: usuario
        });
    } catch (error) {
        console.error('Erro ao verificar sess√£o:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erro interno no servidor' 
        });
    }
});

app.post("/logout", async (req, res) => {
    try {
        const { token } = req.body;
        
        if (!token) {
            return res.status(400).json({ 
                success: false, 
                message: 'Token n√£o fornecido' 
            });
        }

        if (pool) {
            const [result] = await pool.query('DELETE FROM sessoes WHERE token = ?', [token]);
            
            if (result.affectedRows > 0) {
                await registrarLog('logout', { token });
                res.json({ 
                    success: true, 
                    message: 'Logout realizado com sucesso' 
                });
            } else {
                res.status(404).json({ 
                    success: false, 
                    message: 'Sess√£o n√£o encontrada' 
                });
            }
        } else {
            const sessoes = await readData('sessoes');
            
            if (sessoes.sessoes[token]) {
                const email = sessoes.sessoes[token].email;
                delete sessoes.sessoes[token];
                await writeData('sessoes', sessoes);
                await registrarLog('logout', { email });
                
                res.json({ 
                    success: true, 
                    message: 'Logout realizado com sucesso' 
                });
            } else {
                res.status(404).json({ 
                    success: false, 
                    message: 'Sess√£o n√£o encontrada' 
                });
            }
        }
    } catch (error) {
        console.error('Erro no logout:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erro interno no servidor' 
        });
    }
});

// ========== ROTAS DO PAINEL ADMIN ==========

app.get("/health", async (req, res) => {
    try {
        let stats = {};
        
        if (pool) {
            const [academias] = await pool.query('SELECT COUNT(*) as total FROM academias');
            const [proprietarios] = await pool.query('SELECT COUNT(*) as total FROM proprietarios');
            const [personais] = await pool.query('SELECT COUNT(*) as total FROM personais');
            const [usuarios] = await pool.query('SELECT COUNT(*) as total FROM usuarios');
            const [sessoes] = await pool.query('SELECT COUNT(*) as total FROM sessoes WHERE expira_em > NOW()');
            
            stats = {
                academias: academias[0].total,
                proprietarios: proprietarios[0].total,
                personais: personais[0].total,
                usuarios: usuarios[0].total,
                sessoes_ativas: sessoes[0].total
            };
        } else {
            const academias = await readData('academias');
            const proprietarios = await readData('proprietarios');
            const personais = await readData('personais');
            const dbUsuarios = await readData('usuarios');
            
            stats = {
                academias: academias.length,
                proprietarios: proprietarios.length,
                personais: personais.length,
                usuarios: dbUsuarios.total_usuarios || 0,
                sessoes_ativas: 0
            };
        }
        
        res.json({ 
            status: "online",
            message: "Servidor GYM P2 H√çBRIDO funcionando perfeitamente!",
            timestamp: new Date().toISOString(),
            database: pool ? "MySQL ‚úÖ" : "JSON (fallback) ‚ö†Ô∏è",
            stats: stats
        });
    } catch (error) {
        res.status(500).json({ 
            status: "error",
            message: error.message 
        });
    }
});

app.get("/api/health", async (req, res) => {
    if (pool) {
        const [academias] = await pool.query('SELECT COUNT(*) as total FROM academias');
        const [proprietarios] = await pool.query('SELECT COUNT(*) as total FROM proprietarios');
        const [personais] = await pool.query('SELECT COUNT(*) as total FROM personais');
        const [usuarios] = await pool.query('SELECT COUNT(*) as total FROM usuarios');
        
        res.json({ 
            status: "online",
            message: "API GYM P2 H√≠brida Online!",
            usando_mysql: true,
            academias: academias[0].total,
            proprietarios: proprietarios[0].total,
            personais: personais[0].total,
            usuarios: usuarios[0].total
        });
    } else {
        const academias = await readData('academias');
        const proprietarios = await readData('proprietarios');
        const personais = await readData('personais');
        const dbUsuarios = await readData('usuarios');
        
        res.json({ 
            status: "online",
            message: "API GYM P2 H√≠brida Online!",
            usando_mysql: false,
            academias: academias.length,
            proprietarios: proprietarios.length,
            personais: personais.length,
            usuarios: dbUsuarios.total_usuarios || 0
        });
    }
});

app.get("/stats", async (req, res) => {
    try {
        let stats = {};
        
        if (pool) {
            const [academiasStats] = await pool.query(`
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN status = 'ativo' THEN 1 ELSE 0 END) as ativas,
                    SUM(CASE WHEN status = 'inativo' THEN 1 ELSE 0 END) as inativas
                FROM academias
            `);
            
            const [loginsHoje] = await pool.query(`
                SELECT COUNT(*) as total 
                FROM logs 
                WHERE tipo = 'login_sucesso' 
                AND DATE(criado_em) = CURDATE()
            `);
            
            const [totalLogs] = await pool.query('SELECT COUNT(*) as total FROM logs');
            const [totalUsuarios] = await pool.query('SELECT COUNT(*) as total FROM usuarios');
            const [sessoesAtivas] = await pool.query('SELECT COUNT(*) as total FROM sessoes WHERE expira_em > NOW()');
            const [totalProprietarios] = await pool.query('SELECT COUNT(*) as total FROM proprietarios');
            
            stats = {
                sistema: "GYM P2 - MySQL Edition",
                total_usuarios: totalUsuarios[0].total,
                sessoes_ativas: sessoesAtivas[0].total,
                logins_hoje: loginsHoje[0].total,
                total_logs: totalLogs[0].total,
                academias: academiasStats[0].total,
                academias_ativas: academiasStats[0].ativas,
                academias_inativas: academiasStats[0].inativas,
                proprietarios: totalProprietarios[0].total
            };
        } else {
            const db = await readData('usuarios');
            const academias = await readData('academias');
            const proprietarios = await readData('proprietarios');

            const loginsHoje = db.logs ? db.logs.filter(log => {
                const hoje = new Date().toDateString();
                const logDate = new Date(log.timestamp).toDateString();
                return log.tipo === 'login_sucesso' && logDate === hoje;
            }).length : 0;

            stats = {
                sistema: "GYM P2 - Sistema Unificado (JSON)",
                total_usuarios: db.total_usuarios || 0,
                sessoes_ativas: 0,
                logins_hoje: loginsHoje,
                total_logs: db.logs ? db.logs.length : 0,
                academias: academias.length,
                academias_ativas: academias.filter(a => a.status === 'ativo').length,
                academias_inativas: academias.filter(a => a.status === 'inativo').length,
                proprietarios: proprietarios.length
            };
        }
        
        res.json(stats);
    } catch (error) {
        console.error('Erro ao obter stats:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/status", (req, res) => {
    res.json({ 
        status: 'online',
        timestamp: new Date().toISOString(),
        sistema: 'GYM P2 - Servidor H√≠brido',
        versao: '1.0.0',
        database: pool ? 'MySQL' : 'JSON',
        usando_mysql: pool ? true : false
    });
});

// ========== ROTAS ACADEMIAS ==========

app.get("/api/academias", async (req, res) => {
    try {
        if (pool) {
            const [academias] = await pool.query(`
                SELECT a.*, p.nome as proprietario_nome 
                FROM academias a
                LEFT JOIN proprietarios p ON a.proprietario_id = p.id
                ORDER BY a.data_cadastro DESC
            `);
            
            const academiasFormatadas = academias.map(a => ({
                ...a,
                facilidades: a.facilidades ? JSON.parse(a.facilidades) : []
            }));
            
            res.json(academiasFormatadas);
        } else {
            const academias = await readData('academias');
            const proprietarios = await readData('proprietarios');
            
            const result = academias.map(a => ({
                ...a,
                proprietario_nome: proprietarios.find(p => p.id === a.proprietario_id)?.nome || "N√£o informado"
            }));
            
            res.json(result);
        }
    } catch (error) {
        console.error('Erro ao buscar academias:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/api/academias/stats", async (req, res) => {
    try {
        if (pool) {
            const [stats] = await pool.query(`
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN status = 'ativo' THEN 1 ELSE 0 END) as ativas,
                    SUM(CASE WHEN status = 'inativo' THEN 1 ELSE 0 END) as inativas
                FROM academias
            `);
            res.json(stats[0]);
        } else {
            const academias = await readData('academias');
            res.json({
                ativas: academias.filter(a => a.status === 'ativo').length,
                inativas: academias.filter(a => a.status === 'inativo').length,
                total: academias.length
            });
        }
    } catch (error) {
        console.error('Erro ao buscar stats:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/api/academias/:id", async (req, res) => {
    try {
        if (pool) {
            const [rows] = await pool.query(`
                SELECT a.*, p.nome as proprietario_nome, p.email as proprietario_email,
                       p.telefone as proprietario_telefone
                FROM academias a
                LEFT JOIN proprietarios p ON a.proprietario_id = p.id
                WHERE a.id = ?
            `, [req.params.id]);
            
            if (rows.length === 0) {
                return res.status(404).json({ error: 'Academia n√£o encontrada' });
            }
            
            const academia = rows[0];
            academia.facilidades = academia.facilidades ? JSON.parse(academia.facilidades) : [];
            
            res.json(academia);
        } else {
            const academias = await readData('academias');
            const proprietarios = await readData('proprietarios');
            const academia = academias.find(a => a.id == req.params.id);
            
            if (academia) {
                const proprietario = proprietarios.find(p => p.id === academia.proprietario_id);
                res.json({ 
                    ...academia, 
                    proprietario_nome: proprietario?.nome || "N√£o informado",
                    proprietario_email: proprietario?.email || "",
                    proprietario_telefone: proprietario?.telefone || ""
                });
            } else {
                res.status(404).json({ error: 'Academia n√£o encontrada' });
            }
        }
    } catch (error) {
        console.error('Erro ao buscar academia:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.post('/api/academias', async (req, res) => {
    try {
        const academiaData = req.body;
        
        if (pool) {
            const facilidadesText = academiaData.facilidades ? 
                JSON.stringify(academiaData.facilidades) : '[]';
            
            const [result] = await pool.query(`
                INSERT INTO academias 
                (nome, tipo, descricao, cnpj, email, telefone, endereco, cidade, estado, cep, bairro, 
                 numero, complemento, proprietario_id, status, foto_url, preco_mensal, horario_abertura, 
                 horario_fechamento, facilidades, latitude, longitude)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                academiaData.nome,
                academiaData.tipo || 'musculacao',
                academiaData.descricao || '',
                academiaData.cnpj || '',
                academiaData.email || '',
                academiaData.telefone || '',
                academiaData.endereco || '',
                academiaData.cidade || '',
                academiaData.estado || '',
                academiaData.cep || '',
                academiaData.bairro || '',
                academiaData.numero || '',
                academiaData.complemento || '',
                academiaData.proprietario_id || null,
                academiaData.status || 'ativo',
                academiaData.foto_url || '',
                academiaData.preco_mensal || 60,
                academiaData.horario_abertura || '06:00',
                academiaData.horario_fechamento || '22:00',
                facilidadesText,
                academiaData.latitude || null,
                academiaData.longitude || null
            ]);
            
            const [rows] = await pool.query('SELECT * FROM academias WHERE id = ?', [result.insertId]);
            const novaAcademia = rows[0];
            novaAcademia.facilidades = JSON.parse(novaAcademia.facilidades);
            
            io.emit('academia-criada', novaAcademia);
            await notifyPublicUpdate('academia-criada', novaAcademia);
            res.status(201).json(novaAcademia);
        } else {
            const academias = await readData('academias');
            const nova = { 
                id: Date.now(), 
                ...academiaData, 
                data_cadastro: new Date().toISOString() 
            };
            academias.push(nova);
            await writeData('academias', academias);
            io.emit('academia-criada', nova);
            await notifyPublicUpdate('academia-criada', nova);
            res.status(201).json(nova);
        }
    } catch (error) {
        console.error('Erro ao criar academia:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.put('/api/academias/:id', async (req, res) => {
    try {
        const academiaData = req.body;
        
        if (pool) {
            const facilidadesText = academiaData.facilidades ? 
                JSON.stringify(academiaData.facilidades) : '[]';
            
            await pool.query(`
                UPDATE academias SET
                nome = ?, tipo = ?, descricao = ?, cnpj = ?, email = ?, telefone = ?,
                endereco = ?, cidade = ?, estado = ?, cep = ?, bairro = ?, numero = ?,
                complemento = ?, proprietario_id = ?, status = ?, foto_url = ?,
                preco_mensal = ?, horario_abertura = ?, horario_fechamento = ?,
                facilidades = ?, latitude = ?, longitude = ?, data_atualizacao = NOW()
                WHERE id = ?
            `, [
                academiaData.nome,
                academiaData.tipo || 'musculacao',
                academiaData.descricao || '',
                academiaData.cnpj || '',
                academiaData.email || '',
                academiaData.telefone || '',
                academiaData.endereco || '',
                academiaData.cidade || '',
                academiaData.estado || '',
                academiaData.cep || '',
                academiaData.bairro || '',
                academiaData.numero || '',
                academiaData.complemento || '',
                academiaData.proprietario_id || null,
                academiaData.status || 'ativo',
                academiaData.foto_url || '',
                academiaData.preco_mensal || 60,
                academiaData.horario_abertura || '06:00',
                academiaData.horario_fechamento || '22:00',
                facilidadesText,
                academiaData.latitude || null,
                academiaData.longitude || null,
                req.params.id
            ]);
            
            const [rows] = await pool.query('SELECT * FROM academias WHERE id = ?', [req.params.id]);
            const academiaAtualizada = rows[0];
            academiaAtualizada.facilidades = JSON.parse(academiaAtualizada.facilidades);
            
            io.emit('academia-atualizada', academiaAtualizada);
            await notifyPublicUpdate('academia-atualizada', academiaAtualizada);
            res.json(academiaAtualizada);
        } else {
            const academias = await readData('academias');
            const index = academias.findIndex(a => a.id == req.params.id);
            
            if (index !== -1) {
                academias[index] = { 
                    ...academias[index], 
                    ...academiaData, 
                    data_atualizacao: new Date().toISOString() 
                };
                await writeData('academias', academias);
                io.emit('academia-atualizada', academias[index]);
                await notifyPublicUpdate('academia-atualizada', academias[index]);
                res.json(academias[index]);
            } else {
                res.status(404).json({ error: 'Academia n√£o encontrada' });
            }
        }
    } catch (error) {
        console.error('Erro ao atualizar academia:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.delete('/api/academias/:id', async (req, res) => {
    try {
        if (pool) {
            await pool.query('DELETE FROM academias WHERE id = ?', [req.params.id]);
            io.emit('academia-excluida', req.params.id);
            await notifyPublicUpdate('academia-excluida', req.params.id);
            res.json({ 
                success: true, 
                message: 'Academia exclu√≠da com sucesso'
            });
        } else {
            let academias = await readData('academias');
            const index = academias.findIndex(a => a.id == req.params.id);
            
            if (index !== -1) {
                const academiaExcluida = academias[index];
                academias.splice(index, 1);
                await writeData('academias', academias);
                io.emit('academia-excluida', req.params.id);
                await notifyPublicUpdate('academia-excluida', req.params.id);
                res.json({ 
                    success: true, 
                    message: 'Academia exclu√≠da com sucesso',
                    academia: academiaExcluida
                });
            } else {
                res.status(404).json({ error: 'Academia n√£o encontrada' });
            }
        }
    } catch (error) {
        console.error('Erro ao excluir academia:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

// ========== ROTAS PROPRIET√ÅRIOS ==========

app.get("/api/proprietarios", async (req, res) => {
    try {
        if (pool) {
            const [proprietarios] = await pool.query(`
                SELECT p.*, 
                (SELECT COUNT(*) FROM academias a WHERE a.proprietario_id = p.id) as total_academias
                FROM proprietarios p
                ORDER BY p.data_cadastro DESC
            `);
            res.json(proprietarios);
        } else {
            const proprietarios = await readData('proprietarios');
            res.json(proprietarios);
        }
    } catch (error) {
        console.error('Erro ao buscar propriet√°rios:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/api/proprietarios/:id", async (req, res) => {
    try {
        if (pool) {
            const [rows] = await pool.query('SELECT * FROM proprietarios WHERE id = ?', [req.params.id]);
            
            if (rows.length === 0) {
                return res.status(404).json({ 
                    success: false, 
                    error: 'Propriet√°rio n√£o encontrado no MySQL',
                    id: req.params.id
                });
            }
            
            res.json(rows[0]);
        } else {
            const proprietarios = await readData('proprietarios');
            
            const proprietario = proprietarios.find(p => {
                return p.id == req.params.id || 
                       p.id.toString() === req.params.id.toString() ||
                       Number(p.id) === Number(req.params.id);
            });
            
            if (proprietario) {
                res.json(proprietario);
            } else {
                res.status(404).json({ 
                    success: false,
                    error: 'Propriet√°rio n√£o encontrado',
                    requestedId: req.params.id,
                    availableIds: proprietarios.map(p => ({ id: p.id, nome: p.nome }))
                });
            }
        }
    } catch (error) {
        console.error('‚ùå Erro ao buscar propriet√°rio:', error);
        res.status(500).json({ 
            success: false,
            error: 'Erro interno ao buscar propriet√°rio',
            details: error.message 
        });
    }
});

app.post('/api/proprietarios', async (req, res) => {
    try {
        const proprietarioData = req.body;
        
        if (pool) {
            const [result] = await pool.query(`
                INSERT INTO proprietarios (nome, email, cpf, telefone, endereco, data_nascimento, status)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                proprietarioData.nome,
                proprietarioData.email || '',
                proprietarioData.cpf || '',
                proprietarioData.telefone || '',
                proprietarioData.endereco || '',
                proprietarioData.data_nascimento || null,
                proprietarioData.status || 'ativo'
            ]);
            
            const [rows] = await pool.query('SELECT * FROM proprietarios WHERE id = ?', [result.insertId]);
            const novoProprietario = rows[0];
            
            io.emit('proprietario-criado', novoProprietario);
            res.status(201).json(novoProprietario);
        } else {
            const proprietarios = await readData('proprietarios');
            const novo = { 
                id: Date.now(), 
                ...proprietarioData, 
                data_cadastro: new Date().toISOString() 
            };
            proprietarios.push(novo);
            await writeData('proprietarios', proprietarios);
            io.emit('proprietario-criado', novo);
            res.status(201).json(novo);
        }
    } catch (error) {
        console.error('Erro ao criar propriet√°rio:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.put('/api/proprietarios/:id', async (req, res) => {
    try {
        if (pool) {
            const [result] = await pool.query(`
                UPDATE proprietarios SET
                nome = ?, email = ?, cpf = ?, telefone = ?, endereco = ?, 
                data_nascimento = ?, status = ?, data_atualizacao = NOW()
                WHERE id = ?
            `, [
                req.body.nome,
                req.body.email || '',
                req.body.cpf || '',
                req.body.telefone || '',
                req.body.endereco || '',
                req.body.data_nascimento || null,
                req.body.status || 'ativo',
                req.params.id
            ]);
            
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Propriet√°rio n√£o encontrado' });
            }
            
            const [rows] = await pool.query('SELECT * FROM proprietarios WHERE id = ?', [req.params.id]);
            io.emit('proprietario-atualizado', rows[0]);
            res.json(rows[0]);
        } else {
            const proprietarios = await readData('proprietarios');
            const index = proprietarios.findIndex(p => p.id == req.params.id);
            
            if (index !== -1) {
                proprietarios[index] = { 
                    ...proprietarios[index], 
                    ...req.body, 
                    data_atualizacao: new Date().toISOString() 
                };
                await writeData('proprietarios', proprietarios);
                io.emit('proprietario-atualizado', proprietarios[index]);
                res.json(proprietarios[index]);
            } else {
                res.status(404).json({ error: 'Propriet√°rio n√£o encontrado' });
            }
        }
    } catch (error) {
        console.error('Erro ao atualizar propriet√°rio:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.delete('/api/proprietarios/:id', async (req, res) => {
    try {
        if (pool) {
            const [result] = await pool.query('DELETE FROM proprietarios WHERE id = ?', [req.params.id]);
            
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Propriet√°rio n√£o encontrado' });
            }
            
            io.emit('proprietario-excluido', req.params.id);
            res.json({ 
                success: true, 
                message: 'Propriet√°rio exclu√≠do com sucesso'
            });
        } else {
            let proprietarios = await readData('proprietarios');
            const index = proprietarios.findIndex(p => p.id == req.params.id);
            
            if (index !== -1) {
                const proprietarioExcluido = proprietarios[index];
                proprietarios.splice(index, 1);
                await writeData('proprietarios', proprietarios);
                io.emit('proprietario-excluido', req.params.id);
                res.json({ 
                    success: true, 
                    message: 'Propriet√°rio exclu√≠do com sucesso',
                    proprietario: proprietarioExcluido
                });
            } else {
                res.status(404).json({ error: 'Propriet√°rio n√£o encontrado' });
            }
        }
    } catch (error) {
        console.error('Erro ao excluir propriet√°rio:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

// Rota de diagn√≥stico para propriet√°rios
app.get("/api/debug/proprietarios", async (req, res) => {
    try {
        if (pool) {
            const [proprietarios] = await pool.query('SELECT id, nome, email FROM proprietarios ORDER BY id');
            
            res.json({
                usando_mysql: true,
                total: proprietarios.length,
                proprietarios: proprietarios.map(p => ({
                    id: p.id,
                    nome: p.nome,
                    email: p.email
                }))
            });
        } else {
            const proprietarios = await readData('proprietarios');
            
            res.json({
                usando_mysql: false,
                total: proprietarios.length,
                proprietarios: proprietarios.map(p => ({
                    id: p.id,
                    nome: p.nome,
                    email: p.email || ''
                }))
            });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ========== ROTAS PERSONAIS ==========

app.get("/api/personais", async (req, res) => {
    try {
        if (pool) {
            const [personais] = await pool.query(`
                SELECT p.*, a.nome as academia_nome
                FROM personais p
                LEFT JOIN academias a ON p.academia_id = a.id
                ORDER BY p.data_cadastro DESC
            `);
            
            const personaisFormatados = personais.map(p => ({
                ...p,
                bairros: p.bairros ? JSON.parse(p.bairros) : []
            }));
            
            res.json(personaisFormatados);
        } else {
            const personais = await readData('personais');
            const academias = await readData('academias');
            
            const result = personais.map(p => ({
                ...p,
                academia: academias.find(a => a.id === p.academia_id)?.nome || "Independente"
            }));
            
            res.json(result);
        }
    } catch (error) {
        console.error('Erro ao buscar personais:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/api/personais/:id", async (req, res) => {
    try {
        if (pool) {
            const [rows] = await pool.query(`
                SELECT p.*, a.nome as academia_nome, a.endereco as academia_endereco
                FROM personais p
                LEFT JOIN academias a ON p.academia_id = a.id
                WHERE p.id = ?
            `, [req.params.id]);
            
            if (rows.length === 0) {
                return res.status(404).json({ 
                    success: false,
                    error: 'Personal n√£o encontrado',
                    requestedId: req.params.id
                });
            }
            
            const personal = rows[0];
            personal.bairros = personal.bairros ? JSON.parse(personal.bairros) : [];
            
            res.json(personal);
        } else {
            const personais = await readData('personais');
            const academias = await readData('academias');
            
            const personal = personais.find(p => {
                return p.id == req.params.id || 
                       p.id.toString() === req.params.id.toString() ||
                       Number(p.id) === Number(req.params.id);
            });
            
            if (personal) {
                const academiaInfo = personal.academia_id ? 
                    academias.find(a => a.id == personal.academia_id) : null;
                
                const personalCompleto = {
                    ...personal,
                    academia: academiaInfo?.nome || "Independente",
                    academia_info: academiaInfo || null
                };
                
                res.json(personalCompleto);
            } else {
                res.status(404).json({ 
                    success: false,
                    error: 'Personal n√£o encontrado',
                    requestedId: req.params.id,
                    availableIds: personais.map(p => ({ id: p.id, nome: p.nome }))
                });
            }
        }
    } catch (error) {
        console.error('‚ùå Erro ao buscar personal:', error);
        res.status(500).json({ 
            success: false,
            error: 'Erro interno ao buscar personal',
            details: error.message 
        });
    }
});

app.post('/api/personais', async (req, res) => {
    try {
        const personalData = req.body;
        
        if (pool) {
            const bairrosText = personalData.bairros ? JSON.stringify(personalData.bairros) : '[]';
            
            const [result] = await pool.query(`
                INSERT INTO personais 
                (nome, email, telefone, cref, especialidade, anos_experiencia, academia_id, 
                 cidade, bairros, sobre, expectativas, status, avaliacao, foto_url)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                personalData.nome,
                personalData.email || '',
                personalData.telefone || '',
                personalData.cref || '',
                personalData.especialidade || '',
                personalData.anos_experiencia || 0,
                personalData.academia_id || null,
                personalData.cidade || '',
                bairrosText,
                personalData.sobre || '',
                personalData.expectativas || '',
                personalData.status || 'pendente',
                personalData.avaliacao || 0,
                personalData.foto_url || ''
            ]);
            
            const [rows] = await pool.query('SELECT * FROM personais WHERE id = ?', [result.insertId]);
            const novoPersonal = rows[0];
            novoPersonal.bairros = JSON.parse(novoPersonal.bairros);
            
            res.status(201).json(novoPersonal);
        } else {
            const personais = await readData('personais');
            const novo = { 
                id: Date.now(), 
                ...personalData, 
                data_cadastro: new Date().toISOString() 
            };
            personais.push(novo);
            await writeData('personais', personais);
            res.status(201).json(novo);
        }
    } catch (error) {
        console.error('Erro ao criar personal:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.put('/api/personais/:id', async (req, res) => {
    try {
        const personalData = req.body;
        
        if (pool) {
            const bairrosText = personalData.bairros ? JSON.stringify(personalData.bairros) : '[]';
            
            const [result] = await pool.query(`
                UPDATE personais SET
                nome = ?, email = ?, telefone = ?, cref = ?, especialidade = ?,
                anos_experiencia = ?, academia_id = ?, cidade = ?, bairros = ?,
                sobre = ?, expectativas = ?, status = ?, avaliacao = ?, foto_url = ?,
                data_atualizacao = NOW()
                WHERE id = ?
            `, [
                personalData.nome,
                personalData.email || '',
                personalData.telefone || '',
                personalData.cref || '',
                personalData.especialidade || '',
                personalData.anos_experiencia || 0,
                personalData.academia_id || null,
                personalData.cidade || '',
                bairrosText,
                personalData.sobre || '',
                personalData.expectativas || '',
                personalData.status || 'pendente',
                personalData.avaliacao || 0,
                personalData.foto_url || '',
                req.params.id
            ]);
            
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Personal n√£o encontrado' });
            }
            
            const [rows] = await pool.query('SELECT * FROM personais WHERE id = ?', [req.params.id]);
            const personalAtualizado = rows[0];
            personalAtualizado.bairros = JSON.parse(personalAtualizado.bairros);
            
            res.json(personalAtualizado);
        } else {
            const personais = await readData('personais');
            const index = personais.findIndex(p => p.id == req.params.id);
            
            if (index !== -1) {
                personais[index] = { 
                    ...personais[index], 
                    ...personalData, 
                    data_atualizacao: new Date().toISOString() 
                };
                await writeData('personais', personais);
                res.json(personais[index]);
            } else {
                res.status(404).json({ error: 'Personal n√£o encontrado' });
            }
        }
    } catch (error) {
        console.error('Erro ao atualizar personal:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.delete('/api/personais/:id', async (req, res) => {
    try {
        if (pool) {
            const [result] = await pool.query('DELETE FROM personais WHERE id = ?', [req.params.id]);
            
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Personal n√£o encontrado' });
            }
            
            res.json({ 
                success: true, 
                message: 'Personal exclu√≠do com sucesso'
            });
        } else {
            let personais = await readData('personais');
            const index = personais.findIndex(p => p.id == req.params.id);
            
            if (index !== -1) {
                const personalExcluido = personais[index];
                personais.splice(index, 1);
                await writeData('personais', personais);
                res.json({ 
                    success: true, 
                    message: 'Personal exclu√≠do com sucesso',
                    personal: personalExcluido
                });
            } else {
                res.status(404).json({ error: 'Personal n√£o encontrado' });
            }
        }
    } catch (error) {
        console.error('Erro ao excluir personal:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

// ========== ROTAS ADMINISTRADORES ==========

app.get("/api/administradores", async (req, res) => {
    try {
        if (pool) {
            const [admins] = await pool.query(`
                SELECT id, nome, email, nivel, status, telefone, observacoes, 
                       data_cadastro, ultimo_acesso, data_atualizacao
                FROM administradores
                ORDER BY data_cadastro DESC
            `);
            res.json(admins);
        } else {
            const admins = await readData('admins');
            res.json(admins);
        }
    } catch (error) {
        console.error('Erro ao buscar administradores:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.get("/api/administradores/:id", async (req, res) => {
    try {
        if (pool) {
            const [rows] = await pool.query(`
                SELECT id, nome, email, nivel, status, telefone, observacoes,
                       data_cadastro, ultimo_acesso, data_atualizacao
                FROM administradores WHERE id = ?
            `, [req.params.id]);
            
            if (rows.length === 0) {
                return res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }
            
            res.json(rows[0]);
        } else {
            const admins = await readData('admins');
            const admin = admins.find(a => a.id == req.params.id);
            
            if (admin) {
                const { senha, ...adminSemSenha } = admin;
                res.json(adminSemSenha);
            } else {
                res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }
        }
    } catch (error) {
        console.error('Erro ao buscar administrador:', error);
        res.status(500).json({ error: 'Erro interno' });
    }
});

app.post('/api/administradores', async (req, res) => {
    try {
        const { nome, email, senha, nivel, status, telefone, observacoes } = req.body;

        if (!nome || !email || !senha || !nivel) {
            return res.status(400).json({ 
                error: 'Nome, email, senha e n√≠vel s√£o obrigat√≥rios' 
            });
        }

        if (senha.length < 6) {
            return res.status(400).json({ 
                error: 'Senha deve ter no m√≠nimo 6 caracteres' 
            });
        }

        if (pool) {
            const [existing] = await pool.query(
                'SELECT id FROM administradores WHERE email = ?',
                [email]
            );
            
            if (existing.length > 0) {
                return res.status(400).json({ 
                    error: 'Este e-mail j√° est√° cadastrado' 
                });
            }

            const { hash, salt } = hashPassword(senha);

            const [result] = await pool.query(`
                INSERT INTO administradores 
                (nome, email, password_hash, password_salt, nivel, status, telefone, observacoes, criado_por)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                nome,
                email,
                hash,
                salt,
                nivel,
                status || 'ativo',
                telefone || '',
                observacoes || '',
                req.user?.email || 'sistema'
            ]);

            const [rows] = await pool.query(
                'SELECT id, nome, email, nivel, status, telefone, observacoes, data_cadastro FROM administradores WHERE id = ?',
                [result.insertId]
            );

            const novoAdmin = rows[0];
            
            io.emit('admin-criado', novoAdmin);
            
            await registrarLog('admin_criado', {
                admin_email: email,
                criado_por: req.user?.email || 'sistema',
                nivel: nivel
            });
            
            res.status(201).json(novoAdmin);
        } else {
            const admins = await readData('admins');
            
            const emailExistente = admins.find(a => a.email === email);
            if (emailExistente) {
                return res.status(400).json({ 
                    error: 'Este e-mail j√° est√° cadastrado' 
                });
            }

            const { hash, salt } = hashPassword(senha);

            const novoAdmin = {
                id: Date.now(),
                nome,
                email,
                senha: hash,
                salt: salt,
                nivel: nivel,
                status: status || 'ativo',
                telefone: telefone || '',
                observacoes: observacoes || '',
                data_cadastro: new Date().toISOString(),
                ultimo_acesso: null,
                criado_por: req.user?.email || 'sistema'
            };

            admins.push(novoAdmin);
            await writeData('admins', admins);

            io.emit('admin-criado', { id: novoAdmin.id, nome: novoAdmin.nome, email: novoAdmin.email });

            await registrarLog('admin_criado', {
                admin_email: email,
                criado_por: req.user?.email || 'sistema',
                nivel: nivel
            });

            const { senha: _, salt: __, ...adminResponse } = novoAdmin;
            
            res.status(201).json(adminResponse);
        }
    } catch (error) {
        console.error('Erro ao criar administrador:', error);
        res.status(500).json({ error: 'Erro interno no servidor' });
    }
});

app.put('/api/administradores/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { nome, email, senha, nivel, status, telefone, observacoes } = req.body;

        if (pool) {
            const [existing] = await pool.query('SELECT * FROM administradores WHERE id = ?', [id]);
            if (existing.length === 0) {
                return res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }

            const admin = existing[0];

            if (admin.nivel === 'super_admin' && req.user?.role !== 'super_admin') {
                return res.status(403).json({ 
                    error: 'Apenas super administradores podem modificar outros super admins' 
                });
            }

            if (email && email !== admin.email) {
                const [emailCheck] = await pool.query(
                    'SELECT id FROM administradores WHERE email = ? AND id != ?',
                    [email, id]
                );
                if (emailCheck.length > 0) {
                    return res.status(400).json({ 
                        error: 'Este e-mail j√° est√° em uso por outro administrador' 
                    });
                }
            }

            let updateQuery = `
                UPDATE administradores SET
                nome = ?, email = ?, nivel = ?, status = ?, telefone = ?, observacoes = ?,
                data_atualizacao = NOW()
            `;
            let params = [
                nome || admin.nome,
                email || admin.email,
                nivel || admin.nivel,
                status || admin.status,
                telefone || admin.telefone,
                observacoes || admin.observacoes
            ];

            if (senha) {
                if (senha.length < 6) {
                    return res.status(400).json({ 
                        error: 'Senha deve ter no m√≠nimo 6 caracteres' 
                    });
                }
                const { hash, salt } = hashPassword(senha);
                updateQuery += ', password_hash = ?, password_salt = ?';
                params.push(hash, salt);
            }

            updateQuery += ' WHERE id = ?';
            params.push(id);

            await pool.query(updateQuery, params);

            const [rows] = await pool.query(
                'SELECT id, nome, email, nivel, status, telefone, observacoes, data_cadastro, data_atualizacao FROM administradores WHERE id = ?',
                [id]
            );

            io.emit('admin-atualizado', { id, nome: rows[0].nome });

            await registrarLog('admin_atualizado', {
                admin_id: id,
                atualizado_por: req.user?.email || 'sistema'
            });

            res.json(rows[0]);
        } else {
            const admins = await readData('admins');
            const adminIndex = admins.findIndex(a => a.id == id);

            if (adminIndex === -1) {
                return res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }

            if (admins[adminIndex].nivel === 'super_admin' && req.user?.role !== 'super_admin') {
                return res.status(403).json({ 
                    error: 'Apenas super administradores podem modificar outros super admins' 
                });
            }

            if (email && email !== admins[adminIndex].email) {
                const emailExistente = admins.find(a => a.email === email && a.id != id);
                if (emailExistente) {
                    return res.status(400).json({ 
                        error: 'Este e-mail j√° est√° em uso por outro administrador' 
                    });
                }
            }

            admins[adminIndex].nome = nome || admins[adminIndex].nome;
            admins[adminIndex].email = email || admins[adminIndex].email;
            admins[adminIndex].nivel = nivel || admins[adminIndex].nivel;
            admins[adminIndex].status = status || admins[adminIndex].status;
            admins[adminIndex].telefone = telefone;
            admins[adminIndex].observacoes = observacoes;
            admins[adminIndex].data_atualizacao = new Date().toISOString();

            if (senha) {
                if (senha.length < 6) {
                    return res.status(400).json({ 
                        error: 'Senha deve ter no m√≠nimo 6 caracteres' 
                    });
                }
                const { hash, salt } = hashPassword(senha);
                admins[adminIndex].senha = hash;
                admins[adminIndex].salt = salt;
            }

            await writeData('admins', admins);

            io.emit('admin-atualizado', { id, nome: admins[adminIndex].nome });

            await registrarLog('admin_atualizado', {
                admin_id: id,
                atualizado_por: req.user?.email || 'sistema'
            });

            const { senha: _, salt: __, ...adminResponse } = admins[adminIndex];
            
            res.json(adminResponse);
        }
    } catch (error) {
        console.error('Erro ao atualizar administrador:', error);
        res.status(500).json({ error: 'Erro interno no servidor' });
    }
});

app.delete('/api/administradores/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        if (pool) {
            const [existing] = await pool.query('SELECT * FROM administradores WHERE id = ?', [id]);
            if (existing.length === 0) {
                return res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }

            const admin = existing[0];

            if (admin.nivel === 'super_admin') {
                return res.status(403).json({ 
                    error: 'N√£o √© poss√≠vel excluir um Super Administrador' 
                });
            }

            if (req.user?.email === admin.email) {
                return res.status(403).json({ 
                    error: 'Voc√™ n√£o pode excluir sua pr√≥pria conta' 
                });
            }

            const [ativos] = await pool.query(
                'SELECT COUNT(*) as total FROM administradores WHERE status = "ativo" AND id != ?',
                [id]
            );
            if (ativos[0].total === 0) {
                return res.status(403).json({ 
                    error: 'N√£o √© poss√≠vel excluir o √∫ltimo administrador ativo' 
                });
            }

            await pool.query('DELETE FROM administradores WHERE id = ?', [id]);

            io.emit('admin-excluido', id);

            await registrarLog('admin_excluido', {
                admin_email: admin.email,
                excluido_por: req.user?.email || 'sistema'
            });

            res.json({ 
                success: true, 
                message: 'Administrador exclu√≠do com sucesso',
                admin: { id: admin.id, nome: admin.nome, email: admin.email }
            });
        } else {
            const admins = await readData('admins');
            const adminIndex = admins.findIndex(a => a.id == id);

            if (adminIndex === -1) {
                return res.status(404).json({ error: 'Administrador n√£o encontrado' });
            }

            const admin = admins[adminIndex];

            if (admin.nivel === 'super_admin') {
                return res.status(403).json({ 
                    error: 'N√£o √© poss√≠vel excluir um Super Administrador' 
                });
            }

            if (req.user?.email === admin.email) {
                return res.status(403).json({ 
                    error: 'Voc√™ n√£o pode excluir sua pr√≥pria conta' 
                });
            }

            const adminsAtivos = admins.filter(a => a.status === 'ativo' && a.id != id);
            if (adminsAtivos.length === 0) {
                return res.status(403).json({ 
                    error: 'N√£o √© poss√≠vel excluir o √∫ltimo administrador ativo' 
                });
            }

            const adminExcluido = admins.splice(adminIndex, 1)[0];
            await writeData('admins', admins);

            io.emit('admin-excluido', id);

            await registrarLog('admin_excluido', {
                admin_email: adminExcluido.email,
                excluido_por: req.user?.email || 'sistema'
            });

            res.json({ 
                success: true, 
                message: 'Administrador exclu√≠do com sucesso',
                admin: { id: adminExcluido.id, nome: adminExcluido.nome, email: adminExcluido.email }
            });
        }
    } catch (error) {
        console.error('Erro ao excluir administrador:', error);
        res.status(500).json({ error: 'Erro interno no servidor' });
    }
});

// ========== ROTAS P√öBLICAS ==========

app.get("/api/public/academias", async (req, res) => {
    try {
        if (pool) {
            const [academias] = await pool.query(`
                SELECT * FROM academias WHERE status = 'ativo' ORDER BY data_cadastro DESC
            `);
            
            const result = academias.map(a => ({
                id: a.id,
                nome: a.nome,
                displayName: a.nome,
                tipo: a.tipo || 'musculacao',
                preco: a.preco_mensal || 60,
                endereco: a.endereco || '',
                cidade: a.cidade || '',
                estado: a.estado || '',
                telefone: a.telefone || '',
                email: a.email || '',
                foto: a.foto_url || 'https://via.placeholder.com/320x200/1a1a1a/28a745?text=Academia+Gym+P2',
                facilidades: a.facilidades ? JSON.parse(a.facilidades) : [],
                horario: {
                    abertura: a.horario_abertura || '06:00',
                    fechamento: a.horario_fechamento || '22:00'
                },
                schedule: {
                    weekdays: `${a.horario_abertura || '06:00'} - ${a.horario_fechamento || '22:00'}`,
                    weekend: '08:00 - 17:00'
                },
                status: a.status || 'ativo',
                data_atualizacao: a.data_atualizacao || a.data_cadastro,
                location: 'centro',
                address: a.endereco || '',
                description: a.descricao || '',
                adminData: {
                    descricao: a.descricao,
                    email: a.email,
                    telefone: a.telefone,
                    cnpj: a.cnpj
                }
            }));
            
            res.json({
                success: true,
                data: result,
                total: result.length,
                timestamp: new Date().toISOString()
            });
        } else {
            const academias = await readData('academias');
            const academiasAtivas = academias.filter(a => a.status === 'ativo');
            
            const result = academiasAtivas.map(a => ({
                id: a.id,
                nome: a.nome,
                displayName: a.nome,
                tipo: a.tipo || 'musculacao',
                preco: a.preco || 60,
                endereco: a.endereco || '',
                cidade: a.cidade || '',
                estado: a.estado || '',
                telefone: a.telefone || '',
                email: a.email || '',
                foto: a.foto || 'https://via.placeholder.com/320x200/1a1a1a/28a745?text=Academia+Gym+P2',
                facilidades: a.facilidades || [],
                horario: {
                    abertura: a.abertura || '06:00',
                    fechamento: a.fechamento || '22:00'
                },
                schedule: {
                    weekdays: `${a.abertura || '06:00'} - ${a.fechamento || '22:00'}`,
                    weekend: '08:00 - 17:00'
                },
                status: a.status || 'ativo',
                data_atualizacao: a.data_atualizacao || a.data_cadastro,
                location: a.localizacao || 'centro',
                address: a.endereco || '',
                description: a.descricao || '',
                adminData: {
                    descricao: a.descricao,
                    email: a.email,
                    telefone: a.telefone,
                    cnpj: a.cnpj
                }
            }));
            
            res.json({
                success: true,
                data: result,
                total: result.length,
                timestamp: new Date().toISOString()
            });
        }
    } catch (error) {
        console.error('Erro ao buscar academias p√∫blicas:', error);
        res.status(500).json({ 
            success: false, 
            error: 'Erro ao carregar academias' 
        });
    }
});

app.post('/api/personais/cadastro', async (req, res) => {
    try {
        const {
            nome, telefone, email, cidade, bairros,
            especialidade, anos_experiencia, cref,
            sobre, expectativas
        } = req.body;

        if (!nome || !telefone || !email || !cidade || !bairros || !especialidade || !anos_experiencia) {
            return res.status(400).json({ 
                success: false, 
                error: 'Campos obrigat√≥rios faltando' 
            });
        }

        if (pool) {
            const bairrosText = JSON.stringify(bairros.split(',').map(b => b.trim()));
            
            const [result] = await pool.query(`
                INSERT INTO personais 
                (nome, telefone, email, cidade, bairros, especialidade, anos_experiencia, 
                 cref, sobre, expectativas, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pendente')
            `, [
                nome,
                telefone,
                email,
                cidade,
                bairrosText,
                especialidade,
                parseInt(anos_experiencia),
                cref || '',
                sobre || '',
                expectativas || ''
            ]);

            const [rows] = await pool.query('SELECT * FROM personais WHERE id = ?', [result.insertId]);
            const novoPersonal = rows[0];
            novoPersonal.bairros = JSON.parse(novoPersonal.bairros);

            io.emit('personal-cadastrado', novoPersonal);

            await registrarLog('personal_cadastrado', {
                id: novoPersonal.id,
                nome: novoPersonal.nome,
                email: novoPersonal.email,
                cidade: novoPersonal.cidade
            });

            res.status(201).json({
                success: true,
                message: 'Cadastro realizado com sucesso! Aguarde aprova√ß√£o.',
                data: novoPersonal
            });
        } else {
            const personais = await readData('personais');
            
            const novoPersonal = {
                id: Date.now(),
                nome,
                telefone,
                email,
                cidade,
                bairros: bairros.split(',').map(b => b.trim()),
                especialidade,
                anos_experiencia: parseInt(anos_experiencia),
                cref: cref || '',
                sobre,
                expectativas,
                data_cadastro: new Date().toISOString(),
                status: 'pendente',
                tipo: 'independente',
                avaliacao: 0,
                experiencia: `${anos_experiencia} ano(s)`
            };

            personais.push(novoPersonal);
            await writeData('personais', personais);

            io.emit('personal-cadastrado', novoPersonal);

            await registrarLog('personal_cadastrado', {
                id: novoPersonal.id,
                nome: novoPersonal.nome,
                email: novoPersonal.email,
                cidade: novoPersonal.cidade
            });

            res.status(201).json({
                success: true,
                message: 'Cadastro realizado com sucesso! Aguarde aprova√ß√£o.',
                data: novoPersonal
            });
        }
    } catch (error) {
        console.error('Erro no cadastro de personal:', error);
        res.status(500).json({ 
            success: false, 
            error: 'Erro interno no servidor' 
        });
    }
});

// ========== WEBSOCKET ==========
io.on('connection', (socket) => {
    console.log('‚úÖ Cliente WebSocket conectado:', socket.id);
    
    socket.on('join-room', (room) => {
        socket.join(room);
        console.log(`üìç Cliente ${socket.id} entrou na sala: ${room}`);
    });
    
    socket.on('subscribe-public', () => {
        socket.join('public-updates');
        console.log(`üåê Cliente ${socket.id} inscrito em atualiza√ß√µes p√∫blicas`);
    });
    
    socket.on('get-stats', async () => {
        try {
            const stats = await getDashboardStats();
            socket.emit('stats-update', stats);
        } catch (error) {
            console.error('Erro ao buscar stats via WebSocket:', error);
        }
    });
    
    socket.on('atualizar-dashboard', async () => {
        try {
            const stats = await getDashboardStats();
            io.emit('dashboard-atualizado', stats);
        } catch (error) {
            console.error('Erro ao atualizar dashboard:', error);
        }
    });
    
    socket.on('disconnect', () => {
        console.log('‚ùå Cliente desconectado:', socket.id);
    });
});

// ========== INICIAR SERVIDOR ==========
async function startServer() {
    await initDataDir();
    const mysqlConnected = await initDatabase();
    
    server.listen(PORT, '0.0.0.0', () => {
        console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë     üèãÔ∏è  GYM P2 SERVER H√çBRIDO COMPLETO ONLINE üöÄ        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üåê URL: http://localhost:${PORT}                            ‚ïë
‚ïë  üóÑÔ∏è  Banco: ${mysqlConnected ? 'MySQL ‚úÖ' : 'JSON ‚ö†Ô∏è'}       ‚ïë
‚ïë  üîê Sistema: Autentica√ß√£o completa                          ‚ïë
‚ïë  üìä Dashboard: Tempo real com WebSocket                     ‚ïë
‚ïë  üîç Health: /health                                         ‚ïë
‚ïë  üìà Stats: /stats                                           ‚ïë
‚ïë  üìÅ Dados: ${mysqlConnected ? dbConfig.database : './data/'} ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        `);
        
        console.log('\n‚úÖ Rotas principais:');
        console.log('   POST /cadastro                - Cadastrar usu√°rio');
        console.log('   POST /login                   - Login');
        console.log('   POST /logout                  - Logout');
        console.log('   GET  /api/academias           - Listar academias');
        console.log('   GET  /api/proprietarios       - Listar propriet√°rios');
        console.log('   GET  /api/personais           - Listar personais');
        console.log('   GET  /api/administradores     - Listar administradores');
        console.log('   GET  /api/public/academias    - Academias p√∫blicas');
        console.log('   POST /api/personais/cadastro  - Cadastro p√∫blico de personal');
        console.log('   GET  /stats                   - Estat√≠sticas');
        console.log('   GET  /health                  - Status do sistema');
        
        if (!mysqlConnected) {
            console.log('\n‚ö†Ô∏è  MySQL n√£o conectado! Usando JSON local.');
            console.log('   Para usar MySQL:');
            console.log('   1. Verifique se o MySQL est√° rodando');
            console.log('   2. Confirme as credenciais no arquivo');
        }
    });
}

startServer();

// Tratamento de erros
process.on('uncaughtException', (error) => {
    console.error('‚ùå Erro n√£o capturado:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promise rejeitada n√£o tratada:', reason);
});
